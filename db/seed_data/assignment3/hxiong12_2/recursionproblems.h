/*
 * CS 106B Recursion Problems
 * This file declares necessary function prototypes, partly so that other files
 * are able to call the recursive functions you will write.
 * You don't need to modify this file.
 */

#ifndef _recursionwarmups_h
#define _recursionwarmups_h

#include <iostream>
#include "gwindow.h"
#include "vector.h"

// colors for flood fill
#define COLOR_BLACK      0x000000
#define COLOR_DARK_GRAY  0x595959
#define COLOR_GRAY       0x999999
#define COLOR_LIGHT_GRAY 0xBFBFBF
#define COLOR_WHITE      0xFFFFFF
#define COLOR_RED        0xFF0000
#define COLOR_YELLOW     0xFFFF00
#define COLOR_GREEN      0x00FF00
#define COLOR_CYAN       0x00FFFF
#define COLOR_BLUE       0x0000FF
#define COLOR_MAGENTA    0xFF00FF
#define COLOR_ORANGE     0xFFC800
#define COLOR_PINK       0xFFAFAF

// function prototype declarations
int countKarelPaths(int street, int avenue);

/*PROBLEM 2: Converts an input string to an integer*/
int convertStringToInteger(std::string exp);

/*PROBLEM 3:
 * Determines if an input string, consisting only of the characters "()[]{}",
 * has an equal number of opening and closing parenthesis. Does not test
 * nested parenthesis, e.g. ({ )}.
 *Program assumes that the input string contains only allowable characters
 * and does not perform error-checking.*/
bool isBalanced(std::string exp);

/*PROBLEM 4:
 * Draws the Sierpinski Triangle fractal of an order (integer) that is input by the user.
 * The programs draws a fractal if the order is greater than 0.
 * (An order-1 fractal is a single downwards triangle.)*/
void drawSierpinskiTriangle(GWindow& gw, int x, int y, int size, int order);

/*PROBLEM 5:
 * Called by the floodFill method; returns true if a given pixel, denoted by (x, y), is in the range of the
 * graphics window, defined by (width, height).
 * Uses the methods getPixelColor and setPixelColor. */
void floodFill(int x, int y, int width, int height, int color);

/*PROBLEM 6:
 * Generates a random sentence (or "symbol") from an input set of formal language rules.
 * In the file, rules must be formatted as "symbol::=rule|rule|...|rule"
 * Returns a vector of size of an integer input by the user, where each element
 * is a sentence generated by the grammar.
 *Calls on methods readFile and generateSentence.
 *Throws exceptions if:
 * 1) there is a blank symbol in the input grammar file
 * 2) user inputs a blank for the symbol to be generated
 * 3) the input grammar file contains more than one line for the same symbol.*/
Vector<std::string> grammarGenerate(istream& input, string symbol, int times);

// helpers for floodFill

int getPixelColor(int x, int y);
void setPixelColor(int x, int y, int color);

// testing function prototype declarations
void test_karelGoesHome();
void test_convertStringToInteger();
void test_balancingParentheses();
void test_sierpinskiTriangle();
void test_floodFill();
void test_grammarSolver();

#endif
